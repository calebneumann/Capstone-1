"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationApi = void 0;
const sdk_client_1 = require("@sinch/sdk-client");
const conversation_domain_api_1 = require("../conversation-domain-api");
class ConversationApi extends conversation_domain_api_1.ConversationDomainApi {
    /**
     * Initialize your interface
     *
     * @param {SinchClientParameters} sinchClientParameters - The parameters used to initialize the API Client.
     */
    constructor(sinchClientParameters) {
        super(sinchClientParameters, 'ConversationApi');
    }
    /**
     * Create a conversation
     * Creates a new empty conversation. It is generally not needed to create a conversation explicitly since sending or receiving a message automatically creates a new conversation if it does not already exist between the given app and contact. Creating empty conversation is useful if the metadata of the conversation should be populated when the first message in the conversation is a contact message or the first message in the conversation comes out-of-band and needs to be injected with InjectMessage endpoint.
     * @param { CreateConversationRequestData } data - The data to provide to the API call.
     */
    async create(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = data['createConversationRequestBody'] ? JSON.stringify(data['createConversationRequestBody']) : '{}';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'POST', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'CreateConversation',
        });
    }
    /**
     * Delete a conversation
     * Deletes a conversation together with all the messages sent as part of the conversation.
     * @param { DeleteConversationRequestData } data - The data to provide to the API call.
     */
    async delete(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations/${data['conversation_id']}`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'DELETE', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'DeleteConversation',
        });
    }
    /**
     * Get a conversation
     * Retrieves a conversation by id. A conversation has two participating entities, an app and a contact.
     * @param { GetConversationRequestData } data - The data to provide to the API call.
     */
    async get(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations/${data['conversation_id']}`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'GET', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'GetConversation',
        });
    }
    /**
     * Inject an event
     * This operation injects a conversation event into a specific conversation.
     * @param { InjectEventRequestData } data - The data to provide to the API call.
     */
    async injectEvent(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = data['injectConversationEventRequestBody']
            ? JSON.stringify(data['injectConversationEventRequestBody'])
            : '{}';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations/${data['conversation_id']}:inject-event`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'POST', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'InjectEvent',
        });
    }
    /**
     * Inject a message
     * This operation injects a conversation message in to a specific conversation.
     * @param { InjectMessageRequestData } data - The data to provide to the API call.
     */
    async injectMessage(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = data['injectMessageRequestBody'] ? JSON.stringify(data['injectMessageRequestBody']) : '{}';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations/${data['conversation_id']}:inject-message`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'POST', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'InjectMessage',
        });
    }
    /**
     * List conversations
     * This operation lists all conversations that are associated with an app and/or a contact.
     * @param { ListConversationsRequestData } data - The data to provide to the API call.
     * @return {ApiListPromise<Conversation>}
     */
    list(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, [
            'app_id',
            'contact_id',
            'only_active',
            'page_size',
            'page_token',
            'active_channel',
        ]);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations`;
        const requestOptionsPromise = this.client.prepareOptions(basePathUrl, 'GET', getParams, headers, body || undefined);
        const operationProperties = {
            pagination: sdk_client_1.PaginationEnum.TOKEN,
            apiName: this.apiName,
            operationId: 'ListConversations',
            dataKey: 'conversations',
        };
        // Create the promise containing the response wrapped as a PageResult
        const listPromise = (0, sdk_client_1.buildPageResultPromise)(this.client, requestOptionsPromise, operationProperties);
        // Add properties to the Promise to offer the possibility to use it as an iterator
        Object.assign(listPromise, (0, sdk_client_1.createIteratorMethodsForPagination)(this.client, requestOptionsPromise, listPromise, operationProperties));
        return listPromise;
    }
    /**
     * List recent conversations
     * This operation lists conversations and their most recent message, ordered by when the most recent message was sent for that conversation.
     * @param { ListRecentConversationsRequestData } data - The data to provide to the API call.
     * @return {ApiListPromise<ConversationRecentMessage>}
     */
    listRecent(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, [
            'app_id',
            'only_active',
            'page_size',
            'page_token',
            'order',
        ]);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations:recent`;
        const requestOptionsPromise = this.client.prepareOptions(basePathUrl, 'GET', getParams, headers, body || undefined);
        const operationProperties = {
            pagination: sdk_client_1.PaginationEnum.TOKEN,
            apiName: this.apiName,
            operationId: 'ListRecentConversations',
            dataKey: 'conversations',
        };
        // Create the promise containing the response wrapped as a PageResult
        const listPromise = (0, sdk_client_1.buildPageResultPromise)(this.client, requestOptionsPromise, operationProperties);
        // Add properties to the Promise to offer the possibility to use it as an iterator
        Object.assign(listPromise, (0, sdk_client_1.createIteratorMethodsForPagination)(this.client, requestOptionsPromise, listPromise, operationProperties));
        return listPromise;
    }
    /**
     * Stop conversation
     * This operation stops the referenced conversation, if the conversation is still active. A new conversation will be created if a new message is exchanged between the app or contact that was part of the stopped conversation.
     * @param { StopActiveConversationRequestData } data - The data to provide to the API call.
     */
    async stopActive(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations/${data['conversation_id']}:stop`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'POST', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'StopActiveConversation',
        });
    }
    /**
     * Update a conversation
     * This operation updates a conversation which can, for instance, be used to update the metadata associated with a conversation.
     * @param { UpdateConversationRequestData } data - The data to provide to the API call.
     */
    async update(data) {
        this.client = this.getSinchClient();
        data['metadata_update_strategy'] = data['metadata_update_strategy'] !== undefined
            ? data['metadata_update_strategy']
            : 'REPLACE';
        const getParams = this.client.extractQueryParams(data, [
            'update_mask',
            'metadata_update_strategy',
        ]);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = data['updateConversationRequestBody']
            ? JSON.stringify(data['updateConversationRequestBody'])
            : '{}';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v1/projects/${this.client.apiClientOptions.projectId}/conversations/${data['conversation_id']}`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'PATCH', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'UpdateConversation',
        });
    }
}
exports.ConversationApi = ConversationApi;
//# sourceMappingURL=conversation-api.js.map
/// <reference types="node" />
import { ConversationWebhookEvent, WebhookTrigger } from '../../../models';
import { CallbackProcessor } from '@sinch/sdk-client';
import { IncomingHttpHeaders } from 'http';
interface WebhookTriggerEvent {
    trigger: WebhookTrigger;
}
export type ConversationWebhookEventParsed = ConversationWebhookEvent & WebhookTriggerEvent;
export declare class ConversationCallbackWebhooks implements CallbackProcessor<ConversationWebhookEventParsed> {
    private readonly appSecret;
    constructor(appSecret: string);
    /**
     * Validate authorization header for callback request
     * @param {IncomingHttpHeaders} headers - Incoming request's headers
     * @param {any} body - Incoming request's body
     * @param {string} _path - Incoming request's path
     * @param {string} _method - Incoming request's HTTP method
     * @return {boolean} - true if the X-Sinch-Signature header is valid
     */
    validateAuthenticationHeader(headers: IncomingHttpHeaders, body: any, _path?: string, _method?: string): boolean;
    /**
     * Add the trigger corresponding to the trigger
     * 'message' <==> MESSAGE_INBOUND
     * 'message_redaction' <==> MESSAGE_INBOUND_SMART_CONVERSATION_REDACTION
     * 'message_submit_notification' <==> MESSAGE_SUBMIT
     * 'message_delivery_report' <==> MESSAGE_DELIVERY
     * 'event' <==> EVENT_INBOUND
     * 'event_delivery_report' <==> EVENT_DELIVERY
     * 'conversation_start_notification' <==> CONVERSATION_START
     * 'conversation_stop_notification' <==> CONVERSATION_STOP
     * 'conversation_delete_notification' <==> CONVERSATION_DELETE
     * 'contact_create_notification' <==> CONTACT_CREATE
     * 'contact_delete_notification' <==> CONTACT_DELETE
     * 'contact_merge_notification' <==> CONTACT_MERGE
     * 'contact_update_notification' <==> CONTACT_UPDATE
     * 'duplicated_identities' <==> CONTACT_IDENTITIES_DUPLICATION
     * 'capability_notification' <==> CAPABILITY
     * 'opt_in_notification' <==> OPT_IN
     * 'opt_out_notification' <==> OPT_OUT
     * 'channel_event_notification' <==> CHANNEL_EVENT
     * 'unsupported_callback' <==> UNSUPPORTED
     * 'smart_conversation_notification' <==> SMART_CONVERSATIONS
     *
     * @param {any} eventBody - The conversation event to parse
     * @return {ConversationWebhookEventParsed} - Parsed conversation event.
     * @throws {Error} If the eventBody is not valid or cannot be parsed.
     */
    parseEvent(eventBody: any): ConversationWebhookEventParsed;
}
export {};

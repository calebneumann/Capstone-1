"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationCallbackWebhooks = void 0;
const sdk_client_1 = require("@sinch/sdk-client");
class ConversationCallbackWebhooks {
    constructor(appSecret) {
        this.appSecret = appSecret;
    }
    /**
     * Validate authorization header for callback request
     * @param {IncomingHttpHeaders} headers - Incoming request's headers
     * @param {any} body - Incoming request's body
     * @param {string} _path - Incoming request's path
     * @param {string} _method - Incoming request's HTTP method
     * @return {boolean} - true if the X-Sinch-Signature header is valid
     */
    validateAuthenticationHeader(headers, body, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _path, _method) {
        return (0, sdk_client_1.validateWebhookSignature)(this.appSecret, headers, body);
    }
    /**
     * Add the trigger corresponding to the trigger
     * 'message' <==> MESSAGE_INBOUND
     * 'message_redaction' <==> MESSAGE_INBOUND_SMART_CONVERSATION_REDACTION
     * 'message_submit_notification' <==> MESSAGE_SUBMIT
     * 'message_delivery_report' <==> MESSAGE_DELIVERY
     * 'event' <==> EVENT_INBOUND
     * 'event_delivery_report' <==> EVENT_DELIVERY
     * 'conversation_start_notification' <==> CONVERSATION_START
     * 'conversation_stop_notification' <==> CONVERSATION_STOP
     * 'conversation_delete_notification' <==> CONVERSATION_DELETE
     * 'contact_create_notification' <==> CONTACT_CREATE
     * 'contact_delete_notification' <==> CONTACT_DELETE
     * 'contact_merge_notification' <==> CONTACT_MERGE
     * 'contact_update_notification' <==> CONTACT_UPDATE
     * 'duplicated_identities' <==> CONTACT_IDENTITIES_DUPLICATION
     * 'capability_notification' <==> CAPABILITY
     * 'opt_in_notification' <==> OPT_IN
     * 'opt_out_notification' <==> OPT_OUT
     * 'channel_event_notification' <==> CHANNEL_EVENT
     * 'unsupported_callback' <==> UNSUPPORTED
     * 'smart_conversation_notification' <==> SMART_CONVERSATIONS
     *
     * @param {any} eventBody - The conversation event to parse
     * @return {ConversationWebhookEventParsed} - Parsed conversation event.
     * @throws {Error} If the eventBody is not valid or cannot be parsed.
     */
    parseEvent(eventBody) {
        if ('message' in eventBody) {
            return {
                ...eventBody,
                trigger: 'MESSAGE_INBOUND',
            };
        }
        else if ('message_redaction' in eventBody) {
            return {
                ...eventBody,
                trigger: 'MESSAGE_INBOUND_SMART_CONVERSATION_REDACTION',
            };
        }
        else if ('message_submit_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'MESSAGE_SUBMIT',
            };
        }
        else if ('message_delivery_report' in eventBody) {
            return {
                ...eventBody,
                trigger: 'MESSAGE_DELIVERY',
            };
        }
        else if ('event' in eventBody) {
            return {
                ...eventBody,
                trigger: 'EVENT_INBOUND',
            };
        }
        else if ('event_delivery_report' in eventBody) {
            return {
                ...eventBody,
                trigger: 'EVENT_DELIVERY',
            };
        }
        else if ('conversation_start_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONVERSATION_START',
            };
        }
        else if ('conversation_stop_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONVERSATION_STOP',
            };
        }
        else if ('conversation_delete_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONVERSATION_DELETE',
            };
        }
        else if ('contact_create_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONTACT_CREATE',
            };
        }
        else if ('contact_delete_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONTACT_DELETE',
            };
        }
        else if ('contact_merge_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONTACT_MERGE',
            };
        }
        else if ('contact_update_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONTACT_UPDATE',
            };
        }
        else if ('duplicated_identities' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CONTACT_IDENTITIES_DUPLICATION',
            };
        }
        else if ('capability_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CAPABILITY',
            };
        }
        else if ('opt_in_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'OPT_IN',
            };
        }
        else if ('opt_out_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'OPT_OUT',
            };
        }
        else if ('channel_event_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'CHANNEL_EVENT',
            };
        }
        else if ('unsupported_callback' in eventBody) {
            return {
                ...eventBody,
                trigger: 'UNSUPPORTED',
            };
        }
        else if ('smart_conversation_notification' in eventBody) {
            return {
                ...eventBody,
                trigger: 'SMART_CONVERSATIONS',
            };
        }
        else if ('record_notification' in eventBody) { // TBC: need confirmation about the property name
            return {
                ...eventBody,
                trigger: 'RECORD_NOTIFICATION',
            };
        }
        else {
            throw new Error('Unknown Conversation event to parse');
        }
    }
    ;
}
exports.ConversationCallbackWebhooks = ConversationCallbackWebhooks;
//# sourceMappingURL=callbacks-webhook.js.map
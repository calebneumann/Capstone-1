"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reviveDates = exports.invalidateAndRegenerateJwt = exports.buildErrorContext = exports.manageExpiredToken = void 0;
const request_plugin_1 = require("../plugins/core/request-plugin");
const api_errors_1 = require("../api/api-errors");
const manageExpiredToken = async (apiCallParameters, errorContext, requestPlugins, requestOptions, callback) => {
    // Use the circuitBreaker variable to try to regenerate a valid JWT only 3 times
    if (!apiCallParameters.circuitBreaker) {
        apiCallParameters.circuitBreaker = 1;
    }
    else {
        apiCallParameters.circuitBreaker++;
        // Check the circuitBreaker value: if greater than 3, then we stop and throw
        if (apiCallParameters.circuitBreaker >= 3) {
            throw new api_errors_1.GenericError('Tried to generate a new JWT with no success', errorContext);
        }
    }
    const optionsWithNewJwt = await invalidateAndRegenerateJwt(requestPlugins, requestOptions, errorContext);
    const newApiCallParameters = {
        ...apiCallParameters,
        requestOptions: optionsWithNewJwt,
    };
    return callback(newApiCallParameters);
};
exports.manageExpiredToken = manageExpiredToken;
function buildErrorContext(apiCallParameters, origin) {
    return {
        apiName: apiCallParameters.apiName,
        operationId: apiCallParameters.operationId,
        url: apiCallParameters.url,
        origin,
    };
}
exports.buildErrorContext = buildErrorContext;
async function invalidateAndRegenerateJwt(requestPlugins, options, errorContext) {
    const oauth2Plugin = requestPlugins?.find((plugin) => plugin.getName() === request_plugin_1.RequestPluginEnum.OAUTH2_TOKEN_REQUEST);
    if (oauth2Plugin) {
        oauth2Plugin.invalidateToken();
        return oauth2Plugin.load().transform(options);
    }
    else {
        const errorMessage = 'Trying to invalidate an expired JWT while the Oauth2Token plugin is not registered to the API client';
        throw new api_errors_1.GenericError(errorMessage, errorContext);
    }
}
exports.invalidateAndRegenerateJwt = invalidateAndRegenerateJwt;
/**
 * Go through all an object's properties and transform to date the values that match the right format
 * @param {any} input - the response object after all the response plugins have been run
 * @return {any} - the response where the values matching a date are revived as Date objects
 */
const reviveDates = (input) => {
    if (Array.isArray(input)) {
        // Process array elements recursively
        return input.map((item) => (0, exports.reviveDates)(item));
    }
    else if (typeof input === 'object' && input !== null) {
        // Process object properties recursively
        const newObj = {};
        for (const key in input) {
            if (Object.prototype.hasOwnProperty.call(input, key)) {
                newObj[key] = (0, exports.reviveDates)(input[key]);
            }
        }
        return newObj;
    }
    else if (isDateString(input)) {
        // Convert string date to Date object
        return new Date(input);
    }
    else {
        // Return other types as-is
        return input;
    }
};
exports.reviveDates = reviveDates;
const isDateString = (value) => {
    if (typeof value === 'string' && value.length >= 10) {
        const date = new Date(value);
        return !isNaN(date.getTime()) && date.toISOString().slice(0, 10) === value.slice(0, 10);
    }
    return false;
};
//# sourceMappingURL=api-client-helpers.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPageResultPromise = exports.buildPaginationContext = exports.calculateNextPage = exports.hasMore = exports.createNextPageMethod = exports.createIteratorMethodsForPagination = void 0;
const api_client_1 = require("../api/api-client");
class SinchIterator {
    constructor(apiClient, requestOptionsPromise, firstPagePromise, context) {
        this.index = 0;
        this.apiClient = apiClient;
        this.pagePromise = firstPagePromise;
        this.requestOptionsPromise = requestOptionsPromise;
        this.paginatedOperationProperties = context;
    }
    async iterate(pageResult) {
        // If there are more elements to return on the current page
        if (this.index < pageResult.data.length) {
            const value = pageResult.data[this.index];
            this.index += 1;
            return { value, done: false };
        }
        // If there are other pages to getch
        else if (pageResult.hasNextPage) {
            // Reset counter to the first index of the next page
            this.index = 0;
            // Reset the current page to the next one - 'getNextPage' has different implementation depending on the pagination type (TOKEN or PAGE)
            this.pagePromise = this.getNextPage(pageResult);
            // Recursively call the iterator on the next page
            const nextPageResponse = await this.pagePromise;
            return this.iterate(nextPageResponse);
        }
        // No more element on the current page and no more pages to fetch
        return { value: undefined, done: true };
    }
    async getNextPage(pageResult) {
        const requestOptions = await this.requestOptionsPromise;
        if (this.paginatedOperationProperties.pagination === api_client_1.PaginationEnum.TOKEN) {
            const newParams = {
                pageToken: pageResult.nextPageValue,
            };
            return updateQueryParamsAndSendRequest(this.apiClient, newParams, requestOptions, this.paginatedOperationProperties);
        }
        if (this.paginatedOperationProperties.pagination === api_client_1.PaginationEnum.PAGE
            || this.paginatedOperationProperties.pagination === api_client_1.PaginationEnum.PAGE3) {
            const newParams = {
                page: pageResult.nextPageValue,
            };
            return updateQueryParamsAndSendRequest(this.apiClient, newParams, requestOptions, this.paginatedOperationProperties);
        }
        throw new Error(`The operationId "${this.paginatedOperationProperties.operationId}" must define a pagination model`);
    }
    next() {
        return (async () => {
            return this.iterate(await this.pagePromise);
        })();
    }
}
const updateQueryParamsAndSendRequest = (apiClient, newParams, requestOptions, paginatedApiProperties) => {
    const newQueryParams = {
        ...requestOptions.queryParams,
        ...newParams,
    };
    const newRequestOptions = {
        ...requestOptions,
        queryParams: newQueryParams,
    };
    const newUrl = apiClient.prepareUrl(requestOptions.hostname, newQueryParams);
    return apiClient.processCallWithPagination({
        url: newUrl,
        requestOptions: newRequestOptions,
        ...paginatedApiProperties,
    });
};
const createIteratorMethodsForPagination = (apiClient, requestOptionsPromise, firstPagePromise, context) => {
    const iterator = new SinchIterator(apiClient, requestOptionsPromise, firstPagePromise, context);
    const autoPaginationMethods = {
        next: () => iterator.next(),
        return: () => {
            return {};
        },
        [Symbol.asyncIterator]: () => {
            return autoPaginationMethods;
        },
    };
    return autoPaginationMethods;
};
exports.createIteratorMethodsForPagination = createIteratorMethodsForPagination;
const createNextPageMethod = (apiClient, context, requestOptions, nextPageValue) => {
    let newParams;
    switch (context.pagination) {
        case api_client_1.PaginationEnum.TOKEN:
            newParams = {
                pageToken: nextPageValue,
            };
            break;
        case api_client_1.PaginationEnum.PAGE:
        case api_client_1.PaginationEnum.PAGE2:
        case api_client_1.PaginationEnum.PAGE3:
            newParams = {
                page: nextPageValue,
            };
            break;
        default:
            throw new Error(`Error: the pagination method (${context.pagination}) is not supported`);
    }
    const pageResultPromise = updateQueryParamsAndSendRequest(apiClient, newParams, requestOptions, context);
    const requestOptionsPromise = new Promise((resolve) => {
        resolve(requestOptions);
    });
    // Add properties to the Promise to offer the possibility to use it as an iterator
    Object.assign(pageResultPromise, (0, exports.createIteratorMethodsForPagination)(apiClient, requestOptionsPromise, pageResultPromise, context));
    return pageResultPromise;
};
exports.createNextPageMethod = createNextPageMethod;
function hasMore(response, context) {
    if (context.pagination === api_client_1.PaginationEnum.TOKEN) {
        return !!response['nextPageToken'] || !!response['next_page_token'];
    }
    if (context.pagination === api_client_1.PaginationEnum.PAGE) {
        const requestedPageSize = context.requestOptions.queryParams?.page_size;
        const pageSize = requestedPageSize ? parseInt(requestedPageSize) : response.page_size;
        return checkIfThereAreMorePages(response, pageSize, api_client_1.PaginationEnum.PAGE);
    }
    if (context.pagination === api_client_1.PaginationEnum.PAGE2) {
        const requestedPageSize = context.requestOptions.queryParams?.pageSize;
        const pageSize = requestedPageSize ? parseInt(requestedPageSize) : response.pageSize;
        return checkIfThereAreMorePages(response, pageSize, api_client_1.PaginationEnum.PAGE2);
    }
    if (context.pagination === api_client_1.PaginationEnum.PAGE3) {
        return response.pageNumber < response.totalPages;
    }
    throw new Error(`The operation ${context.operationId} is not meant to be paginated.`);
}
exports.hasMore = hasMore;
function calculateNextPage(response, context) {
    if (context.pagination === api_client_1.PaginationEnum.TOKEN) {
        return response['nextPageToken'] || response['next_page_token'];
    }
    if (context.pagination === api_client_1.PaginationEnum.PAGE) {
        const currentPage = response.page || 0;
        const nextPage = currentPage + 1;
        return nextPage.toString();
    }
    if (context.pagination === api_client_1.PaginationEnum.PAGE2 || context.pagination === api_client_1.PaginationEnum.PAGE3) {
        const currentPage = response.pageNumber || 1;
        const nextPage = currentPage + 1;
        return nextPage.toString();
    }
    throw new Error(`The operation ${context.operationId} is not meant to be paginated.`);
}
exports.calculateNextPage = calculateNextPage;
function buildPaginationContext(props) {
    return {
        pagination: props.pagination,
        apiName: props.apiName,
        operationId: props.operationId,
        dataKey: props.dataKey,
        requestOptions: props.requestOptions,
    };
}
exports.buildPaginationContext = buildPaginationContext;
const buildPageResultPromise = async (client, requestOptionsPromise, operationProperties, repeatParamArray) => {
    // Await the promise in this async method and store the result in client so that they can be reused
    const requestOptions = await requestOptionsPromise;
    const url = client.prepareUrl(requestOptions.hostname, requestOptions.queryParams, repeatParamArray);
    return client.processCallWithPagination({
        url,
        requestOptions,
        ...operationProperties,
    });
};
exports.buildPageResultPromise = buildPageResultPromise;
const checkIfThereAreMorePages = (response, requestedPageSize, paginationType) => {
    const lastPageNumber = calculateLastPageValue(response, requestedPageSize, paginationType);
    switch (paginationType) {
        case api_client_1.PaginationEnum.PAGE:
            return response.page < lastPageNumber;
        case api_client_1.PaginationEnum.PAGE2:
            return response.pageNumber < lastPageNumber;
    }
};
const calculateLastPageValue = (response, pageSize, paginationType) => {
    if (invalidatePaginationDataFromResponse(response, paginationType)) {
        throw new Error(`Impossible to calculate the last page value with the following parameters: count=${response.count}, page=${response.page}, page_size=${response.page_size}`);
    }
    if (response.page_size === 0 || response.pageSize === 0) {
        // If there are no elements on the current page, there are no more pages
        return response.page;
    }
    // The elements in the response are not enough to determine if the current page is the last one
    switch (paginationType) {
        case api_client_1.PaginationEnum.PAGE:
            return Math.ceil(response.count / pageSize) - 1;
        case api_client_1.PaginationEnum.PAGE2:
            return Math.ceil(response.totalItems / pageSize) - 1;
    }
};
const invalidatePaginationDataFromResponse = (response, paginationType) => {
    const currentPage = getCurrentPage(response, paginationType);
    const pageSize = getPageSize(response, paginationType);
    const itemCount = getItemCount(response, paginationType);
    return !isNumber(currentPage) || !isNumber(pageSize) || !isNumber(itemCount);
};
const getCurrentPage = (response, paginationType) => {
    switch (paginationType) {
        case api_client_1.PaginationEnum.PAGE:
            return response.page;
        case api_client_1.PaginationEnum.PAGE2:
            return response.pageNumber;
    }
};
const getPageSize = (response, paginationType) => {
    switch (paginationType) {
        case api_client_1.PaginationEnum.PAGE:
            return response.page_size;
        case api_client_1.PaginationEnum.PAGE2:
            return response.pageSize;
    }
};
const getItemCount = (response, paginationType) => {
    switch (paginationType) {
        case api_client_1.PaginationEnum.PAGE:
            return response.count;
        case api_client_1.PaginationEnum.PAGE2:
            return response.totalItems;
    }
};
const isNumber = (value) => {
    return typeof value === 'number' && !isNaN(value);
};
//# sourceMappingURL=api-client-pagination-helper.js.map
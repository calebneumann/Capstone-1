"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiFetchClient = void 0;
const version_1 = require("../plugins/version");
const exception_1 = require("../plugins/exception");
const timezone_1 = require("../plugins/timezone");
const api_client_1 = require("../api/api-client");
const api_errors_1 = require("../api/api-errors");
const node_fetch_1 = __importDefault(require("node-fetch"));
const FormData = require("form-data");
const api_client_helpers_1 = require("./api-client-helpers");
const api_client_pagination_helper_1 = require("./api-client-pagination-helper");
/** Client to process the call to the API using Fetch API */
class ApiFetchClient extends api_client_1.ApiClient {
    /**
     * Initialize your API Client instance with the provided configuration options.
     * Default request plugins: VersionRequest
     * Default response plugins: ExceptionResponse
     *
     * @param {ApiClientOptions} options - Configuration options for the API Client.
     */
    constructor(options) {
        super({
            ...options,
            requestPlugins: [new version_1.VersionRequest(), ...(options.requestPlugins || [])],
            responsePlugins: [
                new timezone_1.TimezoneResponse(),
                new exception_1.ExceptionResponse(),
                ...(options.responsePlugins || []),
            ],
        });
    }
    /** @inheritdoc */
    async processCall(props) {
        // Read the "Origin" header if existing, for logging purposes
        const origin = props.requestOptions.headers.get('Origin');
        const errorContext = (0, api_client_helpers_1.buildErrorContext)(props, origin);
        // Declare variables
        let response;
        let body;
        let exception;
        // Execute call
        try {
            // Send the request with the refresh token mechanism
            response = await this.sinchFetch(props, errorContext);
            body = await response.text();
        }
        catch (error) {
            this.buildFetchError(error, errorContext);
        }
        let result;
        try {
            // Try to parse the body if there is one
            result = body ? JSON.parse(body) : undefined;
        }
        catch (error) {
            exception = new api_errors_1.ResponseJSONParseError(error.message || 'Fail to parse response body', (response && response.status) || 0, errorContext, body);
        }
        // Load and invoke the response plugins to transform the response
        const responsePlugins = this.loadResponsePlugins(this.apiClientOptions.responsePlugins, props, response, exception, origin);
        let transformedResponse = result;
        for (const pluginRunner of responsePlugins) {
            transformedResponse = await pluginRunner.transform(transformedResponse);
        }
        // If there has been an error at some point in the process, throw it
        if (exception) {
            throw exception;
        }
        // If everything went fine, we apply a last transformation to revive the dates, and we return the transformed API response
        return (0, api_client_helpers_1.reviveDates)(transformedResponse);
    }
    async sinchFetch(apiCallParameters, errorContext) {
        const response = await (0, node_fetch_1.default)(apiCallParameters.url, apiCallParameters.requestOptions);
        if (response.status === 401
            && response.headers.get('www-authenticate')?.includes('expired')) {
            return (0, api_client_helpers_1.manageExpiredToken)(apiCallParameters, errorContext, this.apiClientOptions.requestPlugins, apiCallParameters.requestOptions, this.processCall);
        }
        return response;
    }
    processCallWithPagination(props) {
        // Read the "Origin" header if existing, for logging purposes
        const origin = props.requestOptions.headers.get('Origin');
        const errorContext = (0, api_client_helpers_1.buildErrorContext)(props, origin);
        // Execute call
        return this.sinchFetchWithPagination(props, errorContext, origin);
    }
    ;
    async sinchFetchWithPagination(apiCallParameters, errorContext, origin) {
        let exception;
        const response = await (0, node_fetch_1.default)(apiCallParameters.url, apiCallParameters.requestOptions);
        if (response.status === 401
            && response.headers.get('www-authenticate')?.includes('expired')) {
            return (0, api_client_helpers_1.manageExpiredToken)(apiCallParameters, errorContext, this.apiClientOptions.requestPlugins, apiCallParameters.requestOptions, this.processCallWithPagination);
        }
        // When handling pagination, we won't return the raw response but a PageResult
        const body = await response.text();
        let result;
        try {
            // Try to parse the body if there is one
            result = body ? JSON.parse(body) : undefined;
        }
        catch (error) {
            exception = new api_errors_1.ResponseJSONParseError(error.message || 'Fail to parse response body', (response && response.status) || 0, errorContext, body);
        }
        // Load and invoke the response plugins to transform the response
        const responsePlugins = this.loadResponsePlugins(this.apiClientOptions.responsePlugins, apiCallParameters, response, exception, origin);
        let transformedResponse = result;
        for (const pluginRunner of responsePlugins) {
            transformedResponse = await pluginRunner.transform(transformedResponse);
        }
        // Revive Date objects
        transformedResponse = (0, api_client_helpers_1.reviveDates)(transformedResponse);
        // If there has been an error at some point in the process, throw it
        if (exception) {
            throw exception;
        }
        // Read the elements' array with its key
        const responseData = transformedResponse[apiCallParameters.dataKey];
        // Build the PageResult object
        const nextPage = JSON.stringify((0, api_client_pagination_helper_1.calculateNextPage)(transformedResponse, (0, api_client_pagination_helper_1.buildPaginationContext)(apiCallParameters)));
        return {
            data: responseData || [],
            hasNextPage: (0, api_client_pagination_helper_1.hasMore)(transformedResponse, (0, api_client_pagination_helper_1.buildPaginationContext)(apiCallParameters)),
            nextPageValue: nextPage,
            nextPage: () => (0, api_client_pagination_helper_1.createNextPageMethod)(this, (0, api_client_pagination_helper_1.buildPaginationContext)(apiCallParameters), apiCallParameters.requestOptions, nextPage),
        };
    }
    buildFetchError(error, errorContext) {
        if (error instanceof api_errors_1.GenericError) {
            return new api_errors_1.GenericError(error.message, errorContext);
        }
        else {
            return new api_errors_1.EmptyResponseError(error.message || 'Fail to fetch', errorContext, undefined);
        }
    }
    loadResponsePlugins(responsePlugins, apiCallParameters, response, exception, origin) {
        return responsePlugins
            ? responsePlugins.map((plugin) => plugin.load({
                response,
                exception,
                apiName: apiCallParameters.apiName,
                operationId: apiCallParameters.operationId,
                url: apiCallParameters.url,
                requestOptions: apiCallParameters.requestOptions,
                origin,
            }))
            : [];
    }
    /** @inheritdoc */
    async processFileCall(props) {
        // Read the "Origin" header if existing, for logging purposes
        const origin = props.requestOptions.headers.get('Origin');
        const errorContext = (0, api_client_helpers_1.buildErrorContext)(props, origin);
        // Declare variables
        let response;
        let body;
        let fileName;
        // Execute call
        try {
            // Send the request with the refresh token mechanism
            response = await this.sinchFetch(props, errorContext);
            body = await response.buffer();
            fileName = this.extractFileName(response.headers);
        }
        catch (error) {
            this.buildFetchError(error, errorContext);
        }
        if (!body || !fileName) {
            throw new Error('An error occurred while downloading the file');
        }
        return {
            fileName,
            buffer: body,
        };
    }
    extractFileName(headers) {
        const contentDisposition = headers.get('content-disposition');
        let fileName = 'default-name.pdf';
        if (contentDisposition) {
            const match = contentDisposition.match(/filename="([^"]+)"/);
            if (match && match[1]) {
                fileName = match[1];
            }
        }
        return fileName;
    }
    /** @inheritDoc */
    processFormData(data, type) {
        let encodedData;
        if (type === 'multipart/form-data') {
            const formData = new FormData();
            for (const key in data) {
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                    formData.append(key, data[key]);
                }
            }
            encodedData = formData;
        }
        else {
            const formData = [];
            for (const key in data) {
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                    formData.push(`${key}=${encodeURIComponent(data[key])}`);
                }
            }
            encodedData = formData.join('&');
        }
        return encodedData;
    }
}
exports.ApiFetchClient = ApiFetchClient;
//# sourceMappingURL=api-fetch-client.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiClient = exports.PaginationEnum = void 0;
const node_fetch_1 = require("node-fetch");
var PaginationEnum;
(function (PaginationEnum) {
    PaginationEnum[PaginationEnum["NONE"] = 0] = "NONE";
    /** Used by the Numbers API */
    PaginationEnum[PaginationEnum["TOKEN"] = 1] = "TOKEN";
    /** used by the SMS API */
    PaginationEnum[PaginationEnum["PAGE"] = 2] = "PAGE";
    /** used by the Elastic SIP Trunking API */
    PaginationEnum[PaginationEnum["PAGE2"] = 3] = "PAGE2";
    /** used by the Fax API */
    PaginationEnum[PaginationEnum["PAGE3"] = 4] = "PAGE3";
})(PaginationEnum || (exports.PaginationEnum = PaginationEnum = {}));
/**
 * API Client used to call the server
 */
class ApiClient {
    constructor(options) {
        /**
         *
         * @param {string} name - The parameter name
         * @param {Object.<string, string|undefined>} queryParameters - Key-value pair with the parameters. If the value is undefined, the key is dropped.
         * @param {boolean}repeatParamArray - Create as many single parameters with each value of the array
         * @return {string} The query parameter formatted as required by the API
         */
        this.formatQueryParameter = (name, queryParameters = {}, repeatParamArray) => {
            const parameterValue = JSON.parse(queryParameters[name] || '');
            if (Array.isArray(parameterValue)) {
                if (repeatParamArray) {
                    return parameterValue.map((value) => `${name}=${value}`).join('&');
                }
                else {
                    return `${name}=${parameterValue.join(',')}`;
                }
            }
            else {
                return `${name}=${parameterValue}`;
            }
        };
        this.apiClientOptions = options;
    }
    /**
     * Returns a map containing the query parameters based on the provided data and names.
     *
     * @param {Object} data - The data object from which to extract query parameters.
     * @param {Array.<string>} names - An array of keys (property names) to extract from the data object.
     * @return {Object} A map containing the extracted query parameters.
     */
    extractQueryParams(data, names) {
        return names
            .filter((name) => typeof data[name] !== 'undefined' && data[name] !== null)
            .reduce((acc, name) => {
            const prop = data[name];
            acc[name] = typeof prop.toJSON === 'object'
                ? JSON.stringify(prop.toJSON())
                : JSON.stringify(prop);
            return acc;
        }, {});
    }
    /**
     * Asynchronously prepares options for an HTTP request.
     *
     * @param {string} url - The URL for the HTTP request.
     * @param {string} method - The HTTP method for the request (e.g., 'GET', 'POST').
     * @param {Object.<string, (string | undefined)>} queryParams - An object representing query parameters.
     * @param {Object.<string, (string | undefined)>} headers - An object representing headers.
     * @param {RequestBody} [body] - The request body, if applicable.
     * @param {string} [path] - An optional path for the request.
     * @return {Promise<RequestOptions>} A promise that resolves to the prepared options for the HTTP request.
     */
    async prepareOptions(url, method, queryParams, headers, body, path) {
        const options = {
            method,
            headers: new node_fetch_1.Headers(filterUndefinedValues(headers)),
            body,
            queryParams: filterUndefinedValues(queryParams),
            hostname: url,
            path,
        };
        let opts = options;
        if (this.apiClientOptions.requestPlugins) {
            for (const plugin of this.apiClientOptions.requestPlugins) {
                opts = await plugin.load().transform(opts);
            }
        }
        return opts;
    }
    ;
    /**
     * Prepares the url to be called by appending query parameters.
     *
     * @param {string} url - The base url to be used.
     * @param {Object.<string, string|undefined>} queryParameters - Key-value pair with the parameters. If the value is undefined, the key is dropped.
     * @param {boolean} repeatParamArray - create as many single parameters with each value of the array
     * @return {string} The prepared URL as a string.
     */
    prepareUrl(url, queryParameters = {}, repeatParamArray) {
        const queryPart = Object.keys(queryParameters)
            .filter((name) => typeof queryParameters[name] !== 'undefined')
            .map((name) => this.formatQueryParameter(name, queryParameters, repeatParamArray))
            .join('&');
        const paramsPrefix = url.indexOf('?') > -1 ? '&' : '?';
        return url + (!queryPart ? '' : paramsPrefix + queryPart);
    }
    /**
     * Process HTTP call
     * @abstract
     * @template T
     * @param {ApiCallParameters} _httpCallParameters - Parameters for the HTTP call.
     * @return {Promise<T>} A promise that resolves to the result of the HTTP call.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processCall(_httpCallParameters) {
        throw new Error('Abstract method must be implemented');
    }
    /**
     * Process HTTP call with Pagination
     * @abstract
     * @template T
     * @param {ApiCallParametersWithPagination} _httpCallParameters - Parameters for the HTTP call.
     * @return {Promise<T>} A promise that resolves to the result of the HTTP call.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processCallWithPagination(_httpCallParameters) {
        throw new Error('Abstract method must be implemented');
    }
    /**
     * Process HTTP call to download a PDF file
     * @abstract
     * @template T
     * @param {ApiCallParameters} _httpCallParameters - Parameters for the HTTP call.
     * @return {Promise<T>} A promise that resolves to the result of the HTTP call.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processFileCall(_httpCallParameters) {
        throw new Error('Abstract method must be implemented');
    }
    /**
     * Receives an object containing key/value pairs
     * Encodes this object to match application/x-www-urlencoded or multipart/form-data
     * @abstract
     * @param {any} _data
     * @param {string} _type
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processFormData(_data, _type) {
        throw new Error('Abstract method must be implemented');
    }
}
exports.ApiClient = ApiClient;
// ----- INTERNAL ------ \\
/**
 * Returns a filtered JSON object, removing all the undefined values.
 *
 * @param {Object.<string, string|undefined>} object - The JSON object to filter.
 * @return {Object.<string, string>} An object without undefined values.
 */
function filterUndefinedValues(object) {
    return Object.keys(object)
        .filter((objectKey) => typeof object[objectKey] !== 'undefined')
        .reduce((acc, objectKey) => {
        acc[objectKey] = object[objectKey];
        return acc;
    }, {});
}
//# sourceMappingURL=api-client.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateSignature = exports.calculateMD5 = exports.calculateWebhookSignature = exports.computeSignedData = exports.validateSignatureHeader = exports.validateAuthenticationHeader = exports.validateWebhookSignature = exports.generateAuthorizationHeader = void 0;
const crypto_1 = __importDefault(require("crypto"));
const console = __importStar(require("console"));
/**
 * Generate authorization header for application-signed requests (Verification and Voice)
 * @param {string} httpVerb - request's HTTP method
 * @param {RequestBody | undefined} body - request's body (undefined in case of GET request)
 * @param {string} contentType - content-type header value
 * @param {string} canonicalizedHeaders - x-timestamp header
 * @param {string} canonicalizedResource - request's path
 * @param {string} applicationKey - application key (from dashboard)
 * @param {string} applicationSecret - application secret (from dashboard)
 * @return {string} - Application signed header value for HTTP authorization header
 */
const generateAuthorizationHeader = (httpVerb, body, contentType, canonicalizedHeaders, canonicalizedResource, applicationKey, applicationSecret) => {
    const hasBody = !!body;
    const stringToSign = buildStringToSign(httpVerb, hasBody ? (0, exports.calculateMD5)(body) : '', contentType, canonicalizedHeaders, canonicalizedResource);
    const signature = (0, exports.calculateSignature)(applicationSecret, stringToSign);
    return `Application ${applicationKey}:${signature}`;
};
exports.generateAuthorizationHeader = generateAuthorizationHeader;
/**
 * Validate webhook signature headers for Conversation callback.
 * @param {string} secret - secret associated to the Conversation app
 * @param {IncomingHttpHeaders} headers - Incoming request's headers
 * @param {any} body - Incoming request's body
 * @return {boolean} - true if the signature header is valid
 */
const validateWebhookSignature = (secret, headers, body) => {
    const normalizedHeaders = normalizeHeaders(headers);
    const nonce = getHeader(normalizedHeaders['x-sinch-webhook-signature-nonce']);
    const timestamp = getHeader(normalizedHeaders['x-sinch-webhook-signature-timestamp']);
    let bodyAsString = body;
    if (typeof body === 'object' && body !== null) {
        bodyAsString = JSON.stringify(body);
    }
    const signedData = (0, exports.computeSignedData)(bodyAsString, nonce, timestamp);
    const signature = (0, exports.calculateWebhookSignature)(signedData, secret);
    const headerSignature = normalizedHeaders['x-sinch-webhook-signature'];
    return headerSignature === signature;
};
exports.validateWebhookSignature = validateWebhookSignature;
/**
 * Validate authorization header for callback request on application-signed protected endpoints (Verification and Voice webhooks)
 * @param {string} applicationKey - application key (from dashboard) related to the event
 * @param {string} applicationSecret - application secret (from dashboard) related to the event
 * @param {IncomingHttpHeaders} headers - Incoming request's headers
 * @param {any} body - Incoming request's body
 * @param {string} path - Incoming request's path
 * @param {string} method - Incoming request's HTTP method
 * @return {boolean} - true if the authorization header is valid
 */
const validateAuthenticationHeader = (applicationKey, applicationSecret, headers, body, path, method) => {
    const normalizedHeaders = normalizeHeaders(headers);
    const authorization = getHeader(normalizedHeaders.authorization);
    if (typeof authorization === 'undefined') {
        return false;
    }
    const authParts = checkAuthorizationHeaderFormat(authorization);
    if (null === authParts) {
        return false;
    }
    const authorizationScheme = authParts[0].toLowerCase();
    const authorizationValue = authParts[1];
    if (authorizationScheme === 'basic') {
        return validateBasicAuth(authorizationValue, applicationKey, applicationSecret);
    }
    if (authorizationScheme === 'application') {
        return validateApplicationAuth(authorizationValue, normalizedHeaders, applicationKey, applicationSecret, path, body, method);
    }
    // Other schemes than 'basic' or 'application' are not supported
    console.error(`Scheme is not valid: ${authParts[0]}`);
    return false;
};
exports.validateAuthenticationHeader = validateAuthenticationHeader;
/**
 * Validate signature headers for Numbers callback. Note: a callbackURL must be associated to the number
 * @param {string} callbackSecret - secret associated to the rented number
 * @param {IncomingHttpHeaders} headers - Incoming request's headers
 * @param {any} body - Incoming request's body
 * @return {boolean} - true if the signature header is valid
 */
const validateSignatureHeader = (callbackSecret, headers, body) => {
    const normalizedHeaders = normalizeHeaders(headers);
    const signature = getHeader(normalizedHeaders['x-sinch-signature']);
    if (typeof signature === 'undefined') {
        return false;
    }
    const expectedSignature = computeHmacSignature(body, callbackSecret);
    return signature === expectedSignature;
};
exports.validateSignatureHeader = validateSignatureHeader;
// ////////////////
// UTILITY METHODS
const normalizeHeaders = (headers) => {
    return Object.fromEntries(Object.entries(headers)
        .map(([key, value]) => [key.toLowerCase(), value])
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, value]) => value !== undefined));
};
const computeHmacSignature = (body, secret) => {
    return crypto_1.default.createHmac('sha1', secret).update(body).digest('hex');
};
const computeSignedData = (body, nonce, timestamp) => {
    return `${body}.${nonce}.${timestamp}`;
};
exports.computeSignedData = computeSignedData;
const calculateWebhookSignature = (signedData, secret) => {
    return crypto_1.default.createHmac('sha256', secret).update(signedData).digest('base64');
};
exports.calculateWebhookSignature = calculateWebhookSignature;
const validateApplicationAuth = (authorizationValue, normalizedHeaders, applicationKey, applicationSecret, path, body, method) => {
    const authKeyAndSecret = authorizationValue.split(':');
    if (authKeyAndSecret.length !== 2) {
        console.error('Invalid authorization value format provided');
        return false;
    }
    if (authKeyAndSecret[0] !== applicationKey) {
        console.error('Application Key is not valid');
        return false;
    }
    const contentType = getHeader(normalizedHeaders['content-type']);
    const hasBody = !!body;
    const contentMD5 = hasBody ? (0, exports.calculateMD5)(body) : '';
    const stringToSign = buildStringToSign(method.toUpperCase(), contentMD5, contentType, `x-timestamp:${normalizedHeaders['x-timestamp']}`, path);
    const signature = (0, exports.calculateSignature)(applicationSecret, stringToSign);
    if (authKeyAndSecret[1] !== signature) {
        console.error('Invalid signature');
        return false;
    }
    return true;
};
const calculateMD5 = (body) => {
    // Content-MD5 = Base64 ( MD5 ( UTF8 ( [BODY] ) ) )
    return crypto_1.default.createHash('md5').update(Buffer.from(body, 'utf-8')).digest('base64');
};
exports.calculateMD5 = calculateMD5;
const calculateSignature = (secret, stringToSign) => {
    // Signature = Base64 ( HMAC-SHA256 ( Base64-Decode ( ApplicationSecret ), UTF8 ( StringToSign ) ) );
    return crypto_1.default.createHmac('sha256', Buffer.from(secret, 'base64'))
        .update(Buffer.from(stringToSign, 'utf-8'))
        .digest('base64');
};
exports.calculateSignature = calculateSignature;
const buildStringToSign = (httpVerb, contentMD5, contentType, canonicalizedHeaders, canonicalizedResource) => {
    return `${httpVerb}\n${contentMD5}\n${contentType}\n${canonicalizedHeaders}\n${canonicalizedResource}`;
};
const checkAuthorizationHeaderFormat = (authorizationHeader) => {
    const authParts = authorizationHeader.split(' ');
    if (authParts.length !== 2) {
        // The authorization header must be in 2 part: scheme and authorization value
        console.error('Invalid authorization format provided');
        return null;
    }
    return authParts;
};
const validateBasicAuth = (authorization, applicationKey, applicationSecret) => {
    const authKeyAndSecret = authorization.split(':');
    if (authKeyAndSecret.length !== 2) {
        console.error('Invalid authorization value format provided');
        return false;
    }
    if (authKeyAndSecret[0] !== applicationKey || authKeyAndSecret[1] !== applicationSecret) {
        console.error('Invalid credentials provided');
        return false;
    }
    return true;
};
const getHeader = (headerValue) => {
    return Array.isArray(headerValue)
        ? headerValue[0]
        : headerValue;
};
//# sourceMappingURL=authorization.helper.js.map